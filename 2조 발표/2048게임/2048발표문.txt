	2조발표문
안녕하세요. 2조 발표자 노민영입니다.
2조 조원으로는 도광현, 박지호, 노민영, 장혜정 총 4명이며, 저희 조에서 발표할 프로젝트는
홀맨 점프 게임과 2048게임입니다.
발표순서는 프로젝트 개요, 프로젝트 수행절차, 프로젝트 수행결과, 자체 평가의견 순으로 진행 될 예정입니다.
 먼저 홀맨 점프게임에 대한 프로젝트 개요부터 설명을 시작하겠습니다.
 홀맨 프로젝트 개발 일정은 1일차 개발방향 및 의견 수립, 2일차 알고리즘 작성 코딩작성 및 구현하기, 3일차에 통합테스트를 하여 프로그램을 완성하였습니다.
 저희가 구현한 홀맨 점프게임은 구글의 공룡게임을 참고하여  홀맨 점프 게임으로 재구현했습니다.
 홀맨 게임의 수행절차는 알고리즘과 코드작성이 있으며, 알고리즘부터 설명하겠습니다.
게임 스타트하면, 나무가 오른쪽에서 왼쪽에서 오는 코드이며, 홀맨이 점프하는 함수, 홀맨이 바닥 밑으로 더 안떨어지게 하기위한 함수이며, 홀맨이 무한히 올라가면 안되기 때문에 좌표의 위치를 2로 설정하였습니다. 홀맨이 바닥에서 점프하고 나무를 뛰어넘는 모션 함수, 나무를 넘을때마다 score에 점수를 넣는 함수, 이 코드는 저희가 임의로 6단계까지 설정하여 끝까지 완수하면 클리어. 그리고 6단계까지 성공을 하지 못했다면 게임오버가 되면서 다시 시작할 수 있습니다.
 z버튼을 누르면 점프하는 함수, esc를 누르면 멈출 수 있는 코드, 콘솔창에 보이는 나무랑 홀맨의 좌표입니다.
 일번 main코드는 while문을 사용하여 홀맨점프코드를 만들었으며, 2번 main코드에는 장애물인 나무코드와 단계별로 속도가 빨라지는 코드가 있는데 10점씩 증가할때 마다 속도가 점점 빨라집니다.
 프로젝트 수행결과입니다. 걷는 모습 점프하는 모습입니다.
실행되는 화면은 직접 보여드리겠습니다.
 2048게임으로 넘어가겠습니다.
 두번째 프로젝트인 2048게임으로 넘어가겠습니다.
2048프로젝트 개발일정은 1일차에는 개발방향과 의견수립을 하였고, 2, 3동안 알고리즘 및 코딩을 작성하였고, 마지막으로 통합테스트를 하여 프로젝트를 완성하였습니다.
<그대로 읽기>
<그대로 읽기>
2048 수행절차로 알고리즘, 코드작성이 있겠습니다.
<보면서 해석하여 설명>
 저희의 2048 게임 수행결과는 실행화면으로 직접 보여드리겠습니다.
날개는 사진을 참고하여 프린트f로 구현하였습니다. 
실행화면은 직접보여드리겠습니다.
마지막 순서인 자체 평가의견입니다.
이상으로 2조 발표를 마치겠습니다.







두번째로 2048은 4x4의 칸에 2와 4가 나오고 같은 수를 합하여 최종적으로 2048을 만들면 이기는 게임입니다. 원래는 모바일에 상하좌우로 손가락을 움직여 만들지만, 저희는 c를 이용해 컴퓨터로 즐기게 만들었습니다. 2048의 코드로는 ~~~~~~~~~~~~~~~가 있습니다.
	2048
#define _CRT_SECURE_NO_WARNINGS은 scanf_srk[10]개의 사이즈를 받는사고 명시되어 있어서
그 경고를 무시하고 scanf를 계속 사용하기 위해 썼습니다.
2048을 만들때 필요했었던 헤더파일로 타임, 메모리, 윈도우, 코니오, 메쓰, mm시스템
그리고 게임 bgm을 넣을 프라그마 함수입니다.
그 다음 순서로 디파인으로 맵의 좌표를 지정하였으며 게임보드는 2차원 배열로 만들었습니다.
int score = 0;
int max = 0;
int temp_max = 0;
int move = 0;
int over = 0;
int win = 0;
int newnum = 0;
게임을 움직이는 키를 지정한것입니다.

콘솔 색깔과 콘솔크기지정

커서 위치 지정

draw는 게임 배경을 프린트한 코드입니다.

new_num은2나 4를 나오게하는 함수로 제일 중요한것은 밑에 코드인데 빈공간이 있고 rand % 100이 85보다 밑이면 2, 거짓이면 4가 나오게 하였습니다.

레프트버튼 함수로 반복문으로 i열 검사, j열 검사, r을 j에 대입하여 r을 -시키고 -하는 이유는 오른쪽에서 왼쪽으로 움직일때 -를 해야하기 때문입니다.
그리고 board[i][r]이 0일때 break!, 지금 수의 왼쪽이 0일 아닐때, 그리고 옆에 수와 값이 다를때 멈추고, 옆에 수가 0일때 [i][r]을 왼쪽으로 이동해야 하기때문에 왼쪽을 지금 값과 같게 하고, 원래 자리에 있던 값을 영으로 바꾸어 움직인것처럼 보이게 move++을 적었습니다.
else if로 왼쪽값과 지금값이 같거나 지금 값이 10000보다 적으면 왼쪽에 있는 수와 제 수가 같기 때문에 합쳐진것처럼 보이게 왼쪽을 *=2로 하였고 온른쪽은 0, score에 왼쪽값을 더하게 하였습니다.
그리고 왼쪽과 비슷하게 오른쪽 위아래도 이런식으로 코드를 만들었습니다. 


FILE* fp; 메모장이랑 연결하는 포인터 생성함수